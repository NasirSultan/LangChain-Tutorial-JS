import { LanguageModelLike } from "@langchain/core/language_models/base";
import { StructuredToolInterface, DynamicTool } from "@langchain/core/tools";
import { RunnableToolLike } from "@langchain/core/runnables";
import { InteropZodType } from "@langchain/core/utils/types";
import { StateGraph, CompiledStateGraph, AnnotationRoot, MessagesAnnotation } from "@langchain/langgraph";
import { CreateReactAgentParams, withAgentName, AgentNameMode } from "@langchain/langgraph/prebuilt";
export type { AgentNameMode };
export { withAgentName };
type OutputMode = "full_history" | "last_message";
export type CreateSupervisorParams<AnnotationRootT extends AnnotationRoot<any>, StructuredResponseFormat extends Record<string, any> = Record<string, any>> = {
    agents: CompiledStateGraph<AnnotationRootT["State"], AnnotationRootT["Update"], string, AnnotationRootT["spec"], AnnotationRootT["spec"]>[];
    llm: LanguageModelLike;
    tools?: (StructuredToolInterface | RunnableToolLike | DynamicTool)[];
    prompt?: CreateReactAgentParams["prompt"];
    responseFormat?: InteropZodType<StructuredResponseFormat> | {
        prompt: string;
        schema: InteropZodType<StructuredResponseFormat> | Record<string, unknown>;
    } | Record<string, unknown>;
    stateSchema?: AnnotationRootT;
    outputMode?: OutputMode;
    addHandoffBackMessages?: boolean;
    supervisorName?: string;
    includeAgentName?: AgentNameMode;
};
/**
 * Create a multi-agent supervisor.
 *
 * @param agents List of agents to manage
 * @param llm Language model to use for the supervisor
 * @param tools Tools to use for the supervisor
 * @param prompt Optional prompt to use for the supervisor. Can be one of:
 *   - string: This is converted to a SystemMessage and added to the beginning of the list of messages in state["messages"]
 *   - SystemMessage: this is added to the beginning of the list of messages in state["messages"]
 *   - Function: This function should take in full graph state and the output is then passed to the language model
 *   - Runnable: This runnable should take in full graph state and the output is then passed to the language model
 * @param responseFormat An optional schema for the final supervisor output.
 *
 * If provided, output will be formatted to match the given schema and returned in the 'structuredResponse' state key.
 * If not provided, `structuredResponse` will not be present in the output state.
 *
 * Can be passed in as:
 *   - Zod schema
 *   - JSON schema
 *   - { prompt, schema }, where schema is one of the above.
 *        The prompt will be used together with the model that is being used to generate the structured response.
 *
 * @remarks
 * **Important**: `responseFormat` requires the model to support `.withStructuredOutput()`.
 *
 * **Note**: The graph will make a separate call to the LLM to generate the structured response after the agent loop is finished.
 * This is not the only strategy to get structured responses, see more options in [this guide](https://langchain-ai.github.io/langgraph/how-tos/react-agent-structured-output/).
 * @param stateSchema State schema to use for the supervisor graph
 * @param outputMode Mode for adding managed agents' outputs to the message history in the multi-agent workflow.
 *   Can be one of:
 *   - `full_history`: add the entire agent message history
 *   - `last_message`: add only the last message (default)
 * @param addHandoffBackMessages Whether to add a pair of (AIMessage, ToolMessage) to the message history
 *   when returning control to the supervisor to indicate that a handoff has occurred
 * @param supervisorName Name of the supervisor node
 * @param includeAgentName Use to specify how to expose the agent name to the underlying supervisor LLM.
 *   - undefined: Relies on the LLM provider using the name attribute on the AI message. Currently, only OpenAI supports this.
 *   - "inline": Add the agent name directly into the content field of the AI message using XML-style tags.
 *     Example: "How can I help you" -> "<name>agent_name</name><content>How can I help you?</content>"
 */
declare const createSupervisor: <AnnotationRootT extends AnnotationRoot<any> = typeof MessagesAnnotation, StructuredResponseFormat extends Record<string, any> = Record<string, any>>({ agents, llm, tools, prompt, responseFormat, stateSchema, outputMode, addHandoffBackMessages, supervisorName, includeAgentName, }: CreateSupervisorParams<AnnotationRootT, StructuredResponseFormat>) => StateGraph<AnnotationRootT["spec"], AnnotationRootT["State"], AnnotationRootT["Update"], string, AnnotationRootT["spec"], AnnotationRootT["spec"]>;
export { createSupervisor, type OutputMode };
